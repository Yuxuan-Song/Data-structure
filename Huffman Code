#include <stdio.h>
#define MAXN 100               //最大叶节点数 
#define MAXLEAFE 2*MAXN-1     //最大总节点树（叶节点数的二倍减一） 
#define MAXVALUE 100000 

typedef struct tree
{
	int weight;
	int value;
	char name;
	int parent;
	int lchild;
	int rchild;
}HuffNode;
typedef struct code
{
	int start;
	char name;
	int bit[MAXN];
}HuffCode;

int HuffmanTree(HuffNode T[MAXN],int n)
{
	int i,j;
	int m1,m2,x1,x2;
	for(i=0;i<2*n-1;i++)                  //初始化 
	{
		T[i].weight=0;
		T[i].value=0;
		T[i].name='#';
		T[i].parent=-1;
		T[i].lchild=-1;
		T[i].rchild=-1;
	}
	for(i=0;i<n;i++)              //输入每个结点信息
	{
		printf("Please input the %d node:\n",i+1);
		printf("name:\n");
		scanf("%c",&T[i].name);
		getchar();
		printf("weight:\n");
		scanf("%d",&T[i].weight);
		getchar();
	}
	for(i=0;i<n-1;i++)                //选出权值最小的两个节点。i值代表 除原始权值点外 新构成第i个权值点(共n个原始权值，故至多产生n-1个新权值点) 
	{
		m1=m2=MAXVALUE;
		x1=x2=0;
		for(j=0;j<n+i;j++)          //选择无双亲的最小权值作为孩子 
		{
			if(T[j].parent==-1)
			{
				if(m1>T[j].weight)
				{
					m2=m1;
					m1=T[j].weight;
					x2=x1;
					x1=j;
				}
				else if(m2>T[j].weight)
				{
					m2=T[j].weight;
					x2=j;
				}
			}
		}
		T[x1].parent=T[x2].parent=n+i;        //赋值给新构成的权值点 n+i（在第i次循环中） 
		T[n+i].weight=T[x1].weight+T[x2].weight;
		T[n+i].value=n+i;
		T[n+i].lchild=x1;
		T[n+i].rchild=x2;
		printf("The node %c(weight%d) and %c(weight%d) are in %d rolls!\n",T[x1].name,T[x1].weight,T[x2].name,T[x2].weight,i+1);
	}    //每增加一次新权值打印出一次构成新权值元素的权值位置（在对i的循环中）。由于i从0开始，故表示其对应所在行数时要要加一 
}

int HuffmanCode(HuffNode T[MAXLEAFE],HuffCode C[MAXN],int n)
{
	HuffCode cd;    //临时储存每个编码的值 
	int i,j,p;
	for(i=0;i<n;i++)     //对n个叶节点编码，每编一个叶节点执行一次循环(且每次均先进行一次初始化)
	{
		cd.start=n;         //由最高位开始。因检索是由下到上进行，而编码值结果是由上倒下读取。 
		cd.name=T[i].name;    //将霍夫曼树的结点名与编码中对应
		j=i;                //用j变量作为索引（因i表示为第i个结点，不能轻易改变其值） 
		p=T[j].parent;      //找到其双亲结点
		while(p != -1)      //开始循环，进行编码，直到根节点（无双亲）为止
		{
			cd.start--;        //因为从第0位开始编，最多n位，且start初始值为n，故由n-1开始
			if(j == T[p].lchild)
			{
				cd.bit[cd.start]=0;     //左孩子为0 
			}
			else
			{
				cd.bit[cd.start]=1;     //右孩子为1 
			}
			j=p;              //进行到下一父结点，编下一位码 
			p=T[j].parent;
		}
		C[i]=cd;              //将临时变量的值赋给存储编码的C 
	}
}
int ShowCode(HuffNode T[MAXLEAFE],HuffCode C[MAXN],int n)
{
	int i,j;
	for(i=0;i<n;i++)            //第i个叶节点
	{
		printf("The %c code is:\n",T[i].name);
		for(j=C[i].start;j<n;j++)     //编码函数中，通过start--最终已经到达码字起始位，故由start开始循环至第n位结束，即可将一组编码码字输出
		{
			printf("%d",C[i].bit[j]);    //第i个叶结点码字中的第j位 
		}
		printf("\n");        //一个码字结束，回车下一行 
	}
}

int main()
{
	int n;
	HuffNode T[MAXLEAFE];
	HuffCode C[MAXN];
	printf("Please input the note's numbers of tree:\n");
	scanf("%d",&n);
	HuffmanTree(T,n);
	HuffmanCode(T,C,n);
	ShowCode(T,C,n);
}
